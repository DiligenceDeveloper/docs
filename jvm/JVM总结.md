# JAVA虚拟机基础

> Java虚拟机重点需要掌握这几部分的内容：**类加载系统、jvm结构、
垃圾回收**。


## 1.类加载系统

### 1.1 类加载器分类
>类加载器负责加载编译好的.class字节码文件，并装入内存，使JVM可以实例化或以其他方式使用加载后的类。类加载器可以分为：**启动类加载器、扩展类加载器、系统类加载器、用户自定义类加载器**。


#### a.启动类加载器（Bootstrap ClassLoader）

```
由C++实现,负责将放在<JAVA_HOME>/lib目录中或被-Xbootclasspath参数指定路径中的，并且是被虚拟机识别的(如rt.jar)的类库加载到虚拟机内存中。
```

#### b.扩展类加载器 (Extension ClassLoader)

```
由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>/lib/ext目录中的类库，当通过-Djava.ext.dirs指定路径时，会加载制定路径的类库。
```

#### c.系统类加载器 (System ClassLoader)

```
由sun.misc.Launche$App-ClassLoader实现,负责加载用户类路径(classpath)的类库。
```

#### d.用户自定义类加载器 (User ClassLoader)

```
由用户自定义的加载器，由用户控制加载规则，可以手动控制加载过程中的步骤。
```

### 1.2 加载过程
>类加载分为装载、链接、初始化、使用、卸载五步，重点关注**装载、链接、初始化**

#### a.装载
``` 
装载过程如下:
1）通ClassLoader将指定的.class字节码文件(通过类全限定名)加载到JVM；
2）将此类的静态存储结构转化为方法区运行时的数据结构；
3）在堆中生存代表此类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
注意:
1) 在JVM内部以“类全限定名+ClassLoader实例ID”来标明类。
2) 装载过程采用双亲委派模型，保证类加载的安全性。
```

#### b.链接
```
链接分为以下三步:
1) 验证：校验.class文件的正确性，确保文件是否符合规范定义，并且适合当前JVM使用，包括文件格式验证->元数据验证->字节码验证->符号引用验证；
2) 准备：为类分配内存，同时将类中的静态变量赋值为默认值；
3）解析(可选)：把常量池中的符号引用解析为直接引用，这一步也可以在用到相应的引用时再解析。符号引用是指不知道目标的实际地址时用符号来指定，直接引用指直接指向目标的指针。
```
#### c.初始化
```
初始化类中的静态变量,并执行static代码、构造函数。
JVM规范严格定义了何时需要对类进行初始化:
1）遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，加入类还没初始化，则马上对其进行初始化。即new实例化一个类，读取或设置静态字段(不包括final修饰的静态字段)，以及执行静态方法；
2）使用java.lang.reflect.*的方法对类进行反射调用；
3）初始化一个类时，其父类还没有初始化，则先初始化其父类；
4）JVM启动时被标记为启动类的类(简单理解为具有main方法的类)。
```
##2.JVM结构

>jvm分为**java栈、程序计数器、本地方法栈、方法区、堆**，其中方法区和堆是所有线程共享，java栈、程序计数器、本地方法栈是线程私有。

### 2.1 方法区
```
存储了以下数据:
a) 类及其父类的全限定名 (java.lang.Object没有父类)
b) 类的类型(class or interface)
c) 访问修饰符(public,abstract,final)
d) 实现接口的全限定名列表
e) 常量池
f) 字段信息
g) 方法信息
h) 静态变量
i) ClassLoader引用
j) Class引用
```
###2.2 堆
```
a) 堆用于存储对象实例和数组值
b) 堆中存放指向方法区中对应对象类型数据的指针(句柄池、对象中)
c) 堆是所有线程共享的，要考虑同步问题
d) 堆分为新生代、老年代，用于垃圾回收，因此针对不同的垃圾收集策略存放了引用计数器或清扫标记等数据
e) 堆中实例数据还包含了对象锁
```
###2.3 java栈
```
它分为三部分:局部变量区、操作数栈、帧数据区。它为线程私有，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈，java栈由栈帧组成，栈帧存储局部变量表、操作栈、方法返回值，一个帧对应一个方法调用，调用方法时压入栈帧，方法返回时弹出栈帧并抛弃。
```
###2.4 程序计数器
```
线程私有，用于保存当前线程执行的内存地址。由于线程是轮流切换执行的，为了保证线程切换回来后还能恢复原先状态，需要一个独立的计数器，记录之前中断的地方，所以程序计数器是私有的。
```
###2.5 本地方法栈
```
类似于java栈，主要存储了本地方法的调用状态。
```

##3.垃圾回收
> 垃圾回收需要做两件事:**垃圾检测、垃圾回收**

###3.1 垃圾检测算法
```
a) 引用计数法:给一个对象添加引用计数器，每当有地方引用它，计数器就加1,引用失效就减1(存在互相引用导致计数都不为0的情况)。
b) 可达性分析算法:以GC Roots的对象作为起点开始往下搜索，没有任何引用链相连，则证明为可回收对象。对于互相引用的对象，因为GC Roots不可达，所以也是可回收对象。(GC Roots对象:java栈中引用的对象、方法区常量池中引用的对象、本地方法中引用的对象)。
```
### 3.2 回收算法
```
a) 标记-清除:标记所有需要回收的对象，然后统一回收。不足在于，效率低，同时产生大量碎片。
b) 标记-复制:将内存分为相等的两块区域，每次只使用其中一块区域，一块使用完了，就将活着的对象复制到另外一块上，然后清理掉使用过的那块内存。不足是将实际内存缩小为原来的一半。
c) 标记-整理:标记所有需要回收的对象，然后移动这些对象到边界，然后清理掉边界以外的内存
d) 分代收集算法:将堆分为新生代和老年代。新生代分为Eden区和survive0和survive1区，使用复制算法，survive区分别占新生代的10%，当survive区内存超过10%，多余的就进入老年代。老年代使用标记整理算法。
```

### 3.3 垃圾收集器
```
a) Serial收集器:新生代收集器，使用停止复制算法，使用一个线程进行GC，其他线程暂停。
b) ParNew收集器:新生代收集器，使用停止复制算法，多线程GC,其他线程暂停。
c) Parallel收集器:新生代收集器,多线程，关注吞吐量。
d) Serial Old收集器:老年代收集器，使用标记整理(清理、压缩)算法,单线程GC,其他线程暂停。
e) CMS收集器:老年代收集器，使用标记清除算法，多线程GC，其他线程暂停。
f) Parallel Old收集器:老年代收集器,多线程，标记整理(汇总、压缩)算法，关注吞吐量。
g) g1收集器:java8